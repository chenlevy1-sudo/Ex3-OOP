adipartosh0811,chen.levy1234
206916595,206619025

UML design and class responsibilities
=======================================

(According to the UML diagram in UML.pdf.)

1.1 Package image

Image
Immutable wrapper around a 2D pixel array.
Provides getters for width, height and pixels and basic
read/write operations used by the rest of the code.

ImagePadder
Stateless utility that pads an image so that width and height
become powers of two.
Uses white pixels for padding and distributes padding
symmetrically on opposite sides when possible.

ImageSplitter
Stateless utility that splits a padded image into
square sub-images according to a given resolution.
Returns an Image[][] where each entry corresponds to
one sub-image in the original spatial position.

ImageBrightnessCalculator
Computes the average brightness of an Image
using a fixed luminance formula (weighted RGB).
Used by the algorithm for all image brightness computations.

1.2 Package image_char_matching

CharRawBrightness
Computes a raw brightness value for each character in a given
charset by rasterizing it to a bitmap and averaging its pixels.
Stores the results in a static cache so the same character is
never rasterized twice.

CharBrightness
Takes the raw brightness map and normalizes it into the range
[0,1].
Also supports adding/removing characters and keeps the
normalized map consistent with the current charset.

SubImgCharMatcher
Holds the current charset and a normalized brightness value
for every character.
Given a brightness in [0,1] it returns the character whose
brightness is closest to that value.
Also exposes addChar / removeChar so that the shell can
update the charset dynamically.

1.3 Package ascii_art

AsciiArtAlgorithm
Coordinates the full ASCII-art pipeline for a single run:

Pads the image via ImagePadder.

Splits the padded image via ImageSplitter.

Uses ImageBrightnessCalculator to compute the brightness
of every sub-image.

Asks SubImgCharMatcher for the best character for each
brightness value (with an optional reverse mode).
Returns a char[][] representing the final ASCII-art image.
The class also caches the brightness grid of the last
(image, resolution) pair to avoid recomputing it on
repeated runs.

Shell
Interactive command-line shell.
Responsible for:

loading the image

reading commands from the user

managing the current resolution, charset and reverse mode

managing the current output target (console / HTML)

creating a new AsciiArtAlgorithm and running it on every
asciiArt command
The shell owns a single shared SubImgCharMatcher instance
and keeps it in sync with the charset.

AsciiArtException
Custom checked exception used for all user-facing errors
(invalid command, bad arguments, illegal resolution, etc.).
The message is printed directly to the user.

KeyboardInput
Wrapper for reading trimmed lines from standard input.
Used only by the shell.

1.4 Package ascii_output

AsciiOutput (interface)
Abstracts an output target for ASCII art: defines
out(char[][]).

ConsoleAsciiOutput
Implementation that prints the char[][] directly
to standard output.

HtmlAsciiOutput
Implementation that writes the char[][] to an HTML file
using a monospaced font.

Data structures and Java features
====================================

Below are the main data structures we used, where we used them,
and why they fit this assignment.

char[][]
Used in AsciiArtAlgorithm and the output classes as the
in-memory representation of the final ASCII-art image.
A 2D array is natural here because the output is a rectangular
grid and we know its size in advance.

Image[][]
Returned by ImageSplitter.split.
Represents the tiled sub-images of the padded image,
preserving the original row/column layout.
Again, a 2D array is the simplest and most efficient choice
when dimensions are known.

double[][]
Used in AsciiArtAlgorithm to store the brightness grid of
all sub-images.
It parallels the Image[][] structure and lets us access
brightness by (row, col) in O(1).

SortedSet<Character> / TreeSet<Character>
In Shell we store the current charset in a TreeSet.
This gives us:

uniqueness of characters

automatic sorted order when printing the charset

reasonable performance for add/remove operations.
We do not need random indexed access, so a sorted set is a
good fit.

Set<Character> / HashSet<Character>
Inside SubImgCharMatcher we only need to know whether a
character is currently in the charset.
A HashSet provides O(1) average-time add/remove/contains
and does not impose ordering, which we do not need here.

Map<Character, Double> / HashMap
Used in CharRawBrightness, CharBrightness and
SubImgCharMatcher to map each character to its (raw or
normalized) brightness.
A hash map gives constant-time lookup by character, which is
exactly what we need when matching brightness values.

boolean[][] (inside CharRawBrightness)
Represents the rasterized bitmap of a single character.
Using a primitive 2D array is memory efficient and allows
simple looping when computing brightness.

Primitive arrays and basic types
For image dimensions, brightness values and loop indices we
stick to primitives (int, double).
This keeps the implementation simple and avoids unnecessary
boxing.

Overall, the chosen structures keep the code clear, efficient
and close to the conceptual model of the problem (grids of
pixels / characters and maps from characters to brightness).

Exception handling design
============================

We used Java’s exception mechanism to centralize all
user-facing error handling.

We defined a custom checked exception AsciiArtException
for logical input errors in the shell (unknown command,
bad parameters, illegal resolution, too-small charset, etc.).

Each command handler (handleAdd, handleRemove,
handleRes, handleOutput, handleAsciiArt, and the
command dispatcher executeCommand) validates its input.
When an error is detected, the handler throws an
AsciiArtException with the exact message required by the
exercise (for example
"Did not execute due to incorrect command." or
"Did not change resolution due to incorrect format.").

The main input loop in run wraps the call to
executeCommand in a try/catch (AsciiArtException e).
When an exception is caught, the shell prints
e.getMessage() using System.out.println.
All error messages are therefore printed from a single place.

Errors that are not user input (for example, failing to open
the image file and throwing IOException) are handled
separately.
In that case we simply stop the program without printing a
user-facing error, as no specific text for this case is
defined in the instructions.

This design keeps the control flow simple: command handlers
only detect and describe errors, while run is responsible for
actually printing the messages.

Changes to SubImgCharMatcher API
====================================

We did not change the signatures of the methods that were
given in the assignment.
The matcher still exposes a constructor that receives a charset
and a method:

char getCharByImageBrightness(double brightness)

In addition, we added:

A default constructor
SubImgCharMatcher() which initializes the matcher with the
default charset of digits '0'–'9'.
This is only a convenience for the shell and does not break
any existing code, because it adds functionality without
changing existing signatures.

The API still supports adding and removing characters
dynamically via addChar and removeChar, and these methods
update the internal brightness maps accordingly.

Changes to supplied code
===========================

We did not modify any of the classes in the provided
ascii_output package (AsciiOutput, ConsoleAsciiOutput,
HtmlAsciiOutput).
The shell uses them exactly as given by calling
out(char[][]) on the selected output object.

We also did not change the implementation of Image or other
supplied infrastructure classes.
All our logic is implemented in new classes or in the stubs we
were explicitly allowed to complete (Shell,
AsciiArtAlgorithm, SubImgCharMatcher and the helper
classes), without altering the behavior of the provided
components.