------------- ImagePadder (in package image) -----------------

The ImagePadder class is a stateless utility responsible for performing step 1.4.2.1 of the assignment —
padding an input image so that both its width and height become powers of two.
Padding rules:
Padding is added using white pixels.
Padding is distributed symmetrically between opposite sides whenever possible.
Each dimension is padded independently to the smallest power of two greater than or equal to the original value.
If no padding is required, the original image is returned unchanged.
Public API:
Image pad(Image source)
Input:
An Image instance representing the original bitmap.
Output:
A new Image whose dimensions are powers of two and which contains the original image centered inside a white background.
Design notes:
The class is stateless (no fields), following OOP principles and Single-Responsibility.
Image construction uses the provided constructor Image(Color[][] pixelArray, int width, int height).



------------- ImageSlitter (in package image) -----------------

The ImageSplitter class is a stateless utility responsible for step 1.4.2.2 of the assignment:
splitting a padded input image into equal square sub-images according to a given resolution.

The resolution parameter represents the number of sub-images (characters) in each row of the final ASCII output.
Since the padded image width is guaranteed to be divisible by this value, the splitter computes:

the pixel side length of each square block:
blockSize = paddedImageWidth / resolution

the number of block rows:
numRows = paddedImageHeight / blockSize

the number of block columns:
numCols = resolution

The public API:

Image[][] split(int resolution, Image imageToSplit)


The method returns a 2D array of Image objects.
Each element is a square sub-image of size blockSize × blockSize,
and the 2D structure preserves the spatial layout of the original image (rows and columns).
This layout is required in the next stage, where each sub-image is converted into a single ASCII character.

The class contains private helper methods for extracting each block,
keeping the public interface clean and aligned with the Single Responsibility Principle.
It stores no internal state and does not modify the input image.




------------------------ AsciiArtAlgorithm (in package ascii_art) ----------------------------

AsciiArtAlgorithm design
The AsciiArtAlgorithm class is responsible for running a single ASCII-art conversion,
given an Image, a resolution, a charset, and a reverse flag.
The algorithm pads the image to powers of two using ImagePadder,
then splits the padded image into square sub-images using ImageSplitter.
For each sub-image it computes the average brightness with ImageBrightnessCalculator
(using the same luminance formula everywhere),
and then asks SubImgCharMatcher to choose the character whose normalized brightness is closest to the
(possibly reversed) value.
The result is a char[][] matrix which the Shell later passes to the selected AsciiOutput.
This design follows composition: the algorithm delegates padding, splitting, brightness calculation,
and character matching to dedicated helper classes,
which keeps each class focused and makes the code easy to extend without modifying existing components.



----------------------------------------- Caching and efficiency considerations -----------------------------------

To avoid repeated computations, we added several small caching layers on top of the basic algorithm.
First, in AsciiArtAlgorithm we maintain a static cache of the brightness grid for the last
(image, resolution) pair that was processed.
The helper method getSubImageBrightnessGrid() pads and splits the image and
computes the average brightness of every sub-image only on the first run.
Subsequent runs with the same image and resolution
(for example, when only the charset or the reverse flag change) reuse this double[][]
instead of recomputing all brightness values.
This reduces the asymptotic running time of repeated runs from Θ(#pixels) to Θ(#subImages · |charset|),
at the cost of storing one additional double[][] in memory.
Second, in CharRawBrightness we use a global static HashMap<Character, Double> as a cache for raw character brightness.
For every new character we compute its boolean bitmap and brightness at most once;
all future SubImgCharMatcher instances reuse the cached value.
This removes an unnecessary Θ(pixelsPerChar) factor from later runs and keeps memory usage linear
in the number of distinct characters that were ever used.
Finally, we reuse a single SubImgCharMatcher instance across all runs in the Shell.
The matcher internally stores both raw and normalized brightness values in maps.
Normalization is performed only when the charset actually changes (on addChar / removeChar),
and not on every call to the algorithm.
This design satisfies the efficiency requirements of section 1.5 while keeping
the code modular and adhering to the given API.




----------------------------------- Shell and caching usage --------------------------------------

The Shell class holds a single SubImgCharMatcher instance as a field and reuses it across all asciiArt runs.
For every asciiArt command the shell creates a new AsciiArtAlgorithm object,
passing the shared matcher and the current resolution.
This design respects the requirement that a fresh algorithm instance is created on each run,
while still allowing the internal caching mechanisms to be effective:
the matcher keeps its raw and normalized brightness maps between runs,
and the algorithm can reuse the cached sub-image brightness grid for the current image and resolution.
