------------- ImagePadder (in package image) -----------------

The ImagePadder class is a stateless utility responsible for performing step 1.4.2.1 of the assignment —
padding an input image so that both its width and height become powers of two.
Padding rules:
Padding is added using white pixels.
Padding is distributed symmetrically between opposite sides whenever possible.
Each dimension is padded independently to the smallest power of two greater than or equal to the original value.
If no padding is required, the original image is returned unchanged.
Public API:
Image pad(Image source)
Input:
An Image instance representing the original bitmap.
Output:
A new Image whose dimensions are powers of two and which contains the original image centered inside a white background.
Design notes:
The class is stateless (no fields), following OOP principles and Single-Responsibility.
Image construction uses the provided constructor Image(Color[][] pixelArray, int width, int height).



------------- ImageSlitter (in package image) -----------------

The ImageSplitter class is a stateless utility responsible for step 1.4.2.2 of the assignment:
splitting a padded input image into equal square sub-images according to a given resolution.

The resolution parameter represents the number of sub-images (characters) in each row of the final ASCII output.
Since the padded image width is guaranteed to be divisible by this value, the splitter computes:

the pixel side length of each square block:
blockSize = paddedImageWidth / resolution

the number of block rows:
numRows = paddedImageHeight / blockSize

the number of block columns:
numCols = resolution

The public API:

Image[][] split(int resolution, Image imageToSplit)


The method returns a 2D array of Image objects.
Each element is a square sub-image of size blockSize × blockSize,
and the 2D structure preserves the spatial layout of the original image (rows and columns).
This layout is required in the next stage, where each sub-image is converted into a single ASCII character.

The class contains private helper methods for extracting each block,
keeping the public interface clean and aligned with the Single Responsibility Principle.
It stores no internal state and does not modify the input image.




------------------------ AsciiArtAlgorithm (in package ascii_art) ----------------------------

AsciiArtAlgorithm design
The AsciiArtAlgorithm class is responsible for running a single ASCII-art conversion,
given an Image, a resolution, a charset, and a reverse flag.
The algorithm pads the image to powers of two using ImagePadder,
then splits the padded image into square sub-images using ImageSplitter.
For each sub-image it computes the average brightness with ImageBrightnessCalculator
(using the same luminance formula everywhere),
and then asks SubImgCharMatcher to choose the character whose normalized brightness is closest to the
(possibly reversed) value.
The result is a char[][] matrix which the Shell later passes to the selected AsciiOutput.
This design follows composition: the algorithm delegates padding, splitting, brightness calculation,
and character matching to dedicated helper classes,
which keeps each class focused and makes the code easy to extend without modifying existing components.



----------------------------------------- Caching and efficiency considerations -----------------------------------

To avoid repeated computations, we added several small caching layers on top of the basic algorithm.
First, in AsciiArtAlgorithm we maintain a static cache of the brightness grid for the last
(image, resolution) pair that was processed.
The helper method getSubImageBrightnessGrid() pads and splits the image and
computes the average brightness of every sub-image only on the first run.
Subsequent runs with the same image and resolution
(for example, when only the charset or the reverse flag change) reuse this double[][]
instead of recomputing all brightness values.
This reduces the asymptotic running time of repeated runs from Θ(#pixels) to Θ(#subImages · |charset|),
at the cost of storing one additional double[][] in memory.
Second, in CharRawBrightness we use a global static HashMap<Character, Double> as a cache for raw character brightness.
For every new character we compute its boolean bitmap and brightness at most once;
all future SubImgCharMatcher instances reuse the cached value.
This removes an unnecessary Θ(pixelsPerChar) factor from later runs and keeps memory usage linear
in the number of distinct characters that were ever used.
Finally, we reuse a single SubImgCharMatcher instance across all runs in the Shell.
The matcher internally stores both raw and normalized brightness values in maps.
Normalization is performed only when the charset actually changes (on addChar / removeChar),
and not on every call to the algorithm.
This design satisfies the efficiency requirements of section 1.5 while keeping
the code modular and adhering to the given API.




----------------------------------- Shell and caching usage --------------------------------------

The Shell class holds a single SubImgCharMatcher instance as a field and reuses it across all asciiArt runs.
For every asciiArt command the shell creates a new AsciiArtAlgorithm object,
passing the shared matcher and the current resolution.
This design respects the requirement that a fresh algorithm instance is created on each run,
while still allowing the internal caching mechanisms to be effective:
the matcher keeps its raw and normalized brightness maps between runs,
and the algorithm can reuse the cached sub-image brightness grid for the current image and resolution.
# README – ASCII Art Project

### Student Information
- CSE Username: <your_username>
- ID number: <your_id>
- Worked in a pair? No / Yes (Name, ID)

---



## 1. Class Structure (UML-Level Description)

### ImagePadder (package `image`)
Responsible for padding an image to the nearest power-of-two dimensions using symmetric white padding.
Stateless utility performing step 1.4.2.1.

### ImageSplitter (package `image`)
Splits a padded image into square sub-images according to the given resolution.
Stateless, used in step 1.4.2.2.

### AsciiArtAlgorithm (package `ascii_art`)
Coordinates the full ASCII-art process:
- padding the image
- splitting into sub-images
- brightness calculation
- selecting the closest character using `SubImgCharMatcher`
Returns `char[][]` representing the ASCII result.
Uses helper classes via composition.

### SubImgCharMatcher (package `image_char_matching`)
Stores and normalizes character brightness values.
Used by the algorithm to find the best-matching character for each sub-image.

### Shell (package `ascii_art`)
Handles user interaction, command parsing, resolution changes, charset updates, output mode, and runs the algorithm.
Stores one shared `SubImgCharMatcher` instance reused between runs.

---

## 2. Program Flow and Runtime Behavior

During each `asciiArt` command:
1. The Shell creates a new `AsciiArtAlgorithm` instance with:
   - the current image
   - the shared matcher
   - the current resolution
2. The algorithm:
   - pads the image (`ImagePadder`)
   - splits into sub-images (`ImageSplitter`)
   - computes brightness values
   - uses `SubImgCharMatcher` for character selection
3. The resulting matrix is sent to the selected output (`ConsoleAsciiOutput` or `HtmlAsciiOutput`).

### Efficiency
- A brightness grid for `(image, resolution)` is cached inside `AsciiArtAlgorithm`.
- `CharRawBrightness` caches raw brightness per character globally.
- `SubImgCharMatcher` normalizes brightness only when the charset changes.
This reduces repeated work and keeps time complexity low for consecutive runs.

---

## 3. Exception Handling

I defined a checked exception `AsciiArtException` for all user-facing errors.

Command methods (`handleAdd`, `handleRemove`, `handleRes`, `handleOutput`,
`handleAsciiArt`, and unknown commands in `executeCommand`) **throw**
`AsciiArtException` instead of printing errors.

All exceptions are **caught only in** `userInputLoop`, which prints
`e.getMessage()` and continues to the next command, ensuring the shell never exits due to invalid user input.

Image loading failures (`IOException`) cause `run(String imageName)` to return immediately, as required.

### Why exceptions?
Using exceptions ensures:
- separation between logic and UI
- clean control flow (early exit on error)
- centralized message printing
- compliance with the assignment requirement to throw errors where they occur and catch them only once

---

## 4. Use of SubImgCharMatcher API

The Shell holds a single shared `SubImgCharMatcher` instance.
Whenever characters are added or removed from the charset (`add`/`remove` commands), the Shell calls:
- `matcher.addChar(c)`
- `matcher.removeChar(c)`

This keeps the matcher synchronized with the charset and ensures brightness normalization happens only when needed.
The same matcher is reused across all ASCII-art runs to avoid recomputing brightness data for previously added characters.

---

## 5. ASCII Output Components Usage

We used the classes provided in the `ascii_output` package as-is:
- `AsciiOutput`
- `ConsoleAsciiOutput`
- `HtmlAsciiOutput`

No modifications were made.
The Shell simply invokes their public method `out(char[][])` to print the ASCII-art result.

---

